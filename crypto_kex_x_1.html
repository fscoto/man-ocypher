<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">crypto_kex_x_init_client</code>,
  <code class="Nm">crypto_kex_x_init_server</code>,
  <code class="Nm">crypto_kex_x_1</code>, <code class="Nm">crypto_kex_x_2</code>
  &#x2014;
<div class="Nd">one way key exchange for establishing secure channels</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">monocypher.h</a>&gt;</code>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_x_init_client</code>(<var class="Fa">crypto_kex_client_ctx
    *client_ctx</var>, <var class="Fa">uint8_t random_seed[32]</var>,
    <var class="Fa">const uint8_t client_sk[32]</var>, <var class="Fa">const
    uint8_t client_pk[32]</var>, <var class="Fa">const uint8_t
    server_pk[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_x_init_server</code>(<var class="Fa">crypto_kex_server_ctx
    *server_ctx</var>, <var class="Fa">const uint8_t server_sk[32]</var>,
    <var class="Fa">const uint8_t server_pk[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_x_1</code>(<var class="Fa">crypto_kex_client_ctx
    *client_ctx</var>, <var class="Fa">uint8_t session_key[32]</var>,
    <var class="Fa">uint8_t msg1[80]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_x_2</code>(<var class="Fa">crypto_kex_server_ctx
    *server_ctx</var>, <var class="Fa">uint8_t session_key[32]</var>,
    <var class="Fa">uint8_t client_pk[32]</var>, <var class="Fa">conts uint8_t
    msg1[80]</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These functions perform a key exchange between a <i class="Em">client</i> and a
  <i class="Em">server</i> to establish a secure channel. The result of the key
  exchange is a <i class="Em">session key</i> that is suitable for use with
  <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>. The
  <i class="Em">server</i> and the <i class="Em">client</i> each generate a
  long-term X25519 secret key and its corresponding public key ahead of time
  before the key exchange using
  <a class="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>.
  The <i class="Em">client</i> must know the <i class="Em">server's</i> public
  key before performing the key exchange. The <i class="Em">client</i> initiates
  the key exchange.
<p class="Pp">These functions differ from the
    <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
    functions in that the functions described in this page can be used even if a
    server is offline (i.e. asynchronous communication); they have lower
    security guarantees, see
    <a class="Sx" href="#SECURITY_CONSIDERATIONS">SECURITY CONSIDERATIONS</a>.
    If you can, always prefer
    <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>.</p>
<p class="Pp">The arguments are:</p>
<dl class="Bl-tag">
  <dt><var class="Fa">client_ctx</var></dt>
  <dd>A pointer to a <var class="Vt">crypto_kex_client_ctx</var>, i.e. the
      context for the client.</dd>
  <dt><var class="Fa">server_ctx</var></dt>
  <dd>A pointer to a <var class="Vt">crypto_kex_server_ctx</var>, i.e. the
      context for the server.</dd>
  <dt><var class="Fa">random_seed</var></dt>
  <dd>32 randomly generated bytes. See
      <a class="Xr" href="intro.html">intro(3monocypher)</a> for advice about
      generating random bytes (use the operating system's random number
      generator). This argument is not constant because it is wiped after
    use.</dd>
  <dt><var class="Fa">client_sk</var></dt>
  <dd>A 32-byte secret random number. This is a long-term secret used to
      identify the client.</dd>
  <dt><var class="Fa">client_pk</var></dt>
  <dd>The public key corresponding to the <var class="Fa">client_sk</var>,
      generated using
      <a class="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>.
      If <code class="Dv">NULL</code>, the public key will be generated for
    you.</dd>
  <dt><var class="Fa">server_sk</var></dt>
  <dd>A 32-byte secret random number. This is a long-term secret used to
      identify the server.</dd>
  <dt><var class="Fa">server_pk</var></dt>
  <dd>The public key of the server, which must be known to the client before
      making a connection. This is used to authenticate the server's identity.
      It must thus be known to the client before making a connection.</dd>
  <dt><var class="Fa">msg1</var></dt>
  <dd>A 32-byte message, which is generated and sent by the client. It is the
      only message in the key exchange.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Key_exchange_as_the_client"><a class="permalink" href="#Key_exchange_as_the_client">Key
  exchange as the client</a></h2>
When starting a new connection to the server, the client first reads the
  server's public key from the network; then it calls
  <code class="Fn">crypto_client_x_init_client</code>() to initialise a
  <var class="Vt">crypto_kex_client_ctx</var>.
<p class="Pp">After initialising <var class="Fa">client_ctx</var>, the client
    calls <code class="Fn">crypto_kex_x_1</code>() to generate
    <var class="Fa">msg1</var> and the <var class="Fa">session_key</var>; this
    function also wipes the data in <var class="Fa">client_ctx</var>. The client
    proceeds to send <var class="Fa">msg1</var> to the server to complete the
    key exchange.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Key_exchange_as_the_server"><a class="permalink" href="#Key_exchange_as_the_server">Key
  exchange as the server</a></h2>
When accepting a new connection from a client, the server calls
  <code class="Fn">crypto_client_xk1_init_server</code>() to initialise a
  <var class="Vt">crypto_kex_server_ctx</var>. The arguments to
  <code class="Fn">crypto_client_xk1_init_server</code>() are identical to the
  arguments to <code class="Fn">crypto_client_xk1_init_client</code>(), except
  that the server does not need a <var class="Fa">random_seed</var>; no
  <var class="Fa">client_pk</var> can be specified because the server
  authenticates clients only once the handshake completes, which is application
  logic and not part of the key exchange protocol.
<p class="Pp">After initialising <var class="Fa">server_ctx</var>, the server
    waits for the client to send <var class="Fa">msg1</var> and reads it from
    the network. The server then calls <code class="Fn">crypto_kex_x_2</code>()
    with <var class="Fa">msg1</var>, which yields
    <var class="Fa">session_key</var> and <var class="Fa">client_pk</var>, the
    client's public key. The server can use this to authenticate clients by
    their public key; <i class="Em">if possible, always authenticate
    clients</i>. <code class="Fn">crypto_kex_x_2</code>() returns zero on
    success and -1 if the client's message mismatches the key exchange until
    now. <i class="Em">Always check the return value</i>. This function also
    wipes the data in <var class="Fa">server_ctx</var>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<code class="Fn">crypto_kex_x_init_client</code>(),
  <code class="Fn">crypto_kex_x_init_server</code>() and
  <code class="Fn">crypto_kex_x_1</code>() return nothing.
<p class="Pp"><code class="Fn">crypto_kex_x_2</code>() returns 0 on success or
    -1 if the messages were corrupt or mismatched the server's identity.
    Corruption can be caused by transmission errors, programmer error, or an
    attacker's interference.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
These examples use *NIX networking functions to keep the examples concise, but
  any kind of networking code will work. It is assumed that the client and
  server have already established a connection with each other.
<p class="Pp">Client:</p>
<div class="Bd Pp Bd-indent">
<pre>
crypto_kex_client_ctx client_ctx; /* key exchange context */
uint8_t client_sk[32];     /* 32 random bytes long-term secret key */
uint8_t server_pk[32];     /* the server's public key
                            * (known ahead of time) */
uint8_t seed[32];          /* 32 random bytes */
uint8_t buf[80];           /* buffer for the key exchange messages */
uint8_t session_key[32];   /* the resulting session key */
int fd;                    /* the socket of the connection */

/* (generate random bytes in seed) */
crypto_kex_x_init_client(&amp;client_ctx, seed, client_sk, NULL,
        server_pk);
crypto_kex_x_1(&amp;client_ctx, session_key, buf);
if (write(fd, buf, 80) != 80)
    return -2;
/* key exchange complete;
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
<p class="Pp">Server:</p>
<div class="Bd Pp Bd-indent">
<pre>
crypto_kex_ctx server_ctx; /* key exchange context */
uint8_t server_sk[32];     /* 32 random bytes long-term secret key */
uint8_t server_pk[32];     /* public key to server_sk */
uint8_t client_pk[32];     /* the client's public key */
uint8_t seed[32];          /* 32 random bytes */
uint8_t buf[80];           /* buffer for the key exchange messages */
uint8_t session_key[32];   /* the resulting session key */
int fd;                    /* the socket of the connection */

crypto_kex_x_init_server(&amp;server_ctx, server_sk, server_pk);
if (read(fd, buf, 80) != 80)
    return -2;
crypto_kex_1_2(&amp;server_ctx, session_key, client_pk, buf);

/* authenticate client using client_pk now if possible */

/* key exchange complete;
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
  <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>,
  <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>,
  <a class="Xr" href="intro.html">intro(3monocypher)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
These functions are equivalent to an implementation of the X pattern of the
  Noise protocol framework.
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_CONSIDERATIONS"><a class="permalink" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a></h1>
Unlike the
  <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
  family of functions, the functions described on this page suffer from a number
  of security issues:
<dl class="Bl-tag">
  <dt>Limited forward secrecy</dt>
  <dd>If an attacker manages to steal the server's long-term secret key, past
      messages may be recovered.</dd>
  <dt>Replay attacks</dt>
  <dd>The server does not send a random challenge in this.</dd>
  <dt>Key compromise impersonation</dt>
  <dd>If an attacker manages to steal the server's long-term secret key, the
      attacker can impersonate <i class="Em">any</i> client to that server; if
      client identity is tied to authorization, this also means that
      authorization requirements can be bypassed.</dd>
</dl>
<p class="Pp">The reason they are provided is because they work even if the
    other party cannot respond to a key exchange immediately (e.g. if the server
    may not always be available; consider something like crash dumps where a
    program may be used temporarily in an offline environment).</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 6, 2019</td>
    <td class="foot-os">OpenBSD 6.4</td>
  </tr>
</table>
</body>
</html>
