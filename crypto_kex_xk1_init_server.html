<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>CRYPTO_KEX_XK1_INIT_CLIENT(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTO_KEX_XK1_INIT_CLIENT(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">CRYPTO_KEX_XK1_INIT_CLIENT(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">crypto_kex_xk1_init_client</code>,
  <code class="Nm">crypto_kex_xk1_init_server</code>,
  <code class="Nm">crypto_kex_xk1_1</code>,
  <code class="Nm">crypto_kex_xk1_2</code>,
  <code class="Nm">crypto_kex_xk1_3</code>,
  <code class="Nm">crypto_kex_xk1_4</code> &#x2014;
<div class="Nd">interactive key exchange for establishing secure channels</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">monocypher.h</a>&gt;</code>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_init_client</code>(<var class="Fa">crypto_kex_client_ctx
    *client_ctx</var>, <var class="Fa">uint8_t random_seed[32]</var>,
    <var class="Fa">const uint8_t client_sk[32]</var>, <var class="Fa">const
    uint8_t client_pk[32]</var>, <var class="Fa">const uint8_t
    server_pk[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_init_server</code>(<var class="Fa">crypto_kex_server_ctx
    *server_ctx</var>, <var class="Fa">uint8_t random_seed[32]</var>,
    <var class="Fa">const uint8_t server_sk[32]</var>, <var class="Fa">const
    uint8_t server_pk[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_1</code>(<var class="Fa">crypto_kex_client_ctx
    *client_ctx</var>, <var class="Fa">uint8_t msg1[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_2</code>(<var class="Fa">crypto_kex_server_ctx
    *server_ctx</var>, <var class="Fa">uint8_t msg2[48]</var>,
    <var class="Fa">const uint8_t msg1[32]</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_3</code>(<var class="Fa">crypto_kex_client_ctx
    *client_ctx</var>, <var class="Fa">uint8_t session_key[32]</var>,
    <var class="Fa">uint8_t msg3[48]</var>, <var class="Fa">const uint8_t
    msg2[48]</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">crypto_kex_xk1_4</code>(<var class="Fa">crypto_kex_server_ctx
    *server_ctx</var>, <var class="Fa">uint8_t session_key[32]</var>,
    <var class="Fa">uint8_t client_pk[32]</var>, <var class="Fa">const uint8_t
    msg3[48]</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These functions perform a key exchange between a <i class="Em">client</i> and a
  <i class="Em">server</i> to establish a secure channel. The result of the key
  exchange is a <i class="Em">session key</i> that is suitable for use with
  <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>. The
  <i class="Em">server</i> and the <i class="Em">client</i> each generate a
  long-term X25519 secret key and its corresponding public key ahead of time
  before the key exchange using
  <a class="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>.
  These keys are also used by the by each party to verify the other party's
  identity. The <i class="Em">client</i> must know the
  <i class="Em">server's</i> public key before performing the key exchange. The
  <i class="Em">client</i> initiates the key exchange.
<p class="Pp">These functions differ from the
    <a class="Xr" href="crypto_kex_x_init_client.html">crypto_kex_x_init_client(3monocypher)</a>
    functions in that the functions described in this page provide stronger
    security guarantees, but also require the server to be able to respond to a
    connection from a client immediately.</p>
<p class="Pp">The arguments are:</p>
<dl class="Bl-tag">
  <dt><var class="Fa">client_ctx</var></dt>
  <dd>A pointer to a <var class="Vt">crypto_kex_client_ctx</var>, i.e. the
      context for the client.</dd>
  <dt><var class="Fa">server_ctx</var></dt>
  <dd>A pointer to a <var class="Vt">crypto_kex_server_ctx</var>, i.e. the
      context for the server.</dd>
  <dt><var class="Fa">random_seed</var></dt>
  <dd>32 randomly generated bytes. The server and the client must
      <i class="Em">each</i> generate a <var class="Fa">random_seed</var>. See
      <a class="Xr" href="intro.html">intro(3monocypher)</a> for advice about
      generating random bytes (use the operating system's random number
      generator). This argument is not constant because it is wiped after
    use.</dd>
  <dt><var class="Fa">client_sk</var></dt>
  <dd>A 32-byte secret random number. This is a long-term secret used to
      identify the client.</dd>
  <dt><var class="Fa">client_pk</var></dt>
  <dd>The public key corresponding to the <var class="Fa">client_sk</var>,
      generated using
      <a class="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>.
      If <code class="Dv">NULL</code>, the public key will be generated for
    you.</dd>
  <dt><var class="Fa">server_sk</var></dt>
  <dd>A 32-byte secret random number. This is a long-term secret used to
      identify the server.</dd>
  <dt><var class="Fa">server_pk</var></dt>
  <dd>The public key of the server. This is used to authenticate the server's
      identity. It must thus be known to the client before making a
    connection.</dd>
  <dt><var class="Fa">msg1</var></dt>
  <dd>A 32-byte message, which is generated and sent by the client. It starts
      the actual key exchange.</dd>
  <dt><var class="Fa">msg2</var></dt>
  <dd>A 48-byte message, which is generated and sent by the server.</dd>
  <dt><var class="Fa">msg3</var></dt>
  <dd>A 48-byte message, which is generated and sent by the client. This is the
      final message in the key exchange.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Key_exchange_as_the_client"><a class="permalink" href="#Key_exchange_as_the_client">Key
  exchange as the client</a></h2>
When starting a new connection to the server, the client first calls
  <code class="Fn">crypto_client_xk1_init_client</code>() to initialise a
  <var class="Vt">crypto_kex_client_ctx</var>. After initialising
  <var class="Fa">client_ctx</var>, the client calls
  <code class="Fn">crypto_kex_xk1_1</code>() to generate
  <var class="Fa">msg1</var>. It proceeds to send <var class="Fa">msg1</var> to
  the server. The client then reads <var class="Fa">msg2</var> from the server.
  It calls <code class="Fn">crypto_kex_xk1_3</code>(), which yields the
  <var class="Fa">session_key</var> and <var class="Fa">msg3</var>.
  <code class="Fn">crypto_kex_xk1_3</code>() returns zero on success and -1 if
  the server's message mismatches the key exchange until now.
  <i class="Em">Always check the return value</i>. This function also wipes the
  data in <var class="Fa">client_ctx</var>. The client sends
  <var class="Fa">msg3</var> to the server to complete the key exchange.
</section>
<section class="Ss">
<h2 class="Ss" id="Key_exchange_as_the_server"><a class="permalink" href="#Key_exchange_as_the_server">Key
  exchange as the server</a></h2>
When accepting a new connection from a client, the server first calls
  <code class="Fn">crypto_client_xk1_init_server</code>() to initialise a
  <var class="Vt">crypto_kex_server_ctx</var>. The arguments to
  <code class="Fn">crypto_client_xk1_init_server</code>() are identical to the
  arguments to <code class="Fn">crypto_client_xk1_init_client</code>(), except
  that the server does not know the client's public key yet, so no
  <var class="Fa">client_pk</var> can be specified because the server
  authenticates clients once the handshake completes; the server's
  <var class="Fa">server_sk</var> and <var class="Fa">server_pk</var> are
  generated ahead of time and known to the clients.
<p class="Pp">After initialising <var class="Fa">server_ctx</var>, the server
    waits for the client to send <var class="Fa">msg1</var> and reads it from
    the network. The server then calls
    <code class="Fn">crypto_kex_xk1_2</code>() with <var class="Fa">msg1</var>,
    which yields <var class="Fa">msg2</var>. <var class="Fa">msg2</var> is sent
    to the client. The server reads the client's response
    (<var class="Fa">msg3</var>) from the network and calls
    <code class="Fn">crypto_kex_xk1_4</code>() with <var class="Fa">msg3</var>,
    which yields <var class="Fa">session_key</var> and
    <var class="Fa">client_pk</var>, the client's public key. The server can use
    this to authenticate clients by their public key; <i class="Em">if possible,
    always authenticate clients</i>. <code class="Fn">crypto_kex_xk1_4</code>()
    returns zero on success and -1 if the client's message mismatches the key
    exchange until now. <i class="Em">Always check the return value</i>. This
    function also wipes the data in <var class="Fa">server_ctx</var>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<code class="Fn">crypto_kex_xk1_init_client</code>(),
  <code class="Fn">crypto_kex_xk1_init_server</code>(),
  <code class="Fn">crypto_kex_xk1_1</code>() and
  <code class="Fn">crypto_kex_xk1_2</code>() return nothing.
<p class="Pp"><code class="Fn">crypto_kex_xk1_3</code>() and
    <code class="Fn">crypto_kex_xk1_4</code>() return 0 on success or -1 if the
    messages were corrupt or mismatched the server's identity. Corruption can be
    caused by transmission errors, programmer error, or an attacker's
    interference.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
These examples use *NIX networking functions to keep the examples readable, but
  any kind of networking code will work. It is assumed that the client and
  server have already established a connection with each other.
<p class="Pp">Client:</p>
<div class="Bd Pp Bd-indent">
<pre>
crypto_kex_client_ctx client_ctx; /* key exchange context */
uint8_t client_sk[32];     /* 32 random bytes long-term secret key */
uint8_t server_pk[32];     /* the server's public key
                            * (known ahead of time) */
uint8_t seed[32];          /* 32 random bytes */
uint8_t buf[48];           /* buffer for the key exchange messages */
uint8_t session_key[32];   /* the resulting session key */
int fd;                    /* the socket of the connection */

/* (generate random bytes in seed here) */
crypto_kex_xk1_init_client(&amp;client_ctx, seed, client_sk, NULL,
                           server_pk);
crypto_kex_xk1_1(&amp;client_ctx, buf);
if (write(fd, buf, 32) != 32)
    return -1;
if (read(fd, buf, 48) != 48)
    return -2;
if (crypto_kex_xk1_3(&amp;client_ctx, session_key, buf, buf) != 0)
    return -3;
if (write(fd, buf, 48) != 48)
    return -4;
/* key exchange complete;
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
<p class="Pp">Server:</p>
<div class="Bd Pp Bd-indent">
<pre>
crypto_kex_server_ctx server_ctx; /* key exchange context */
uint8_t server_sk[32];     /* 32 random bytes long-term secret key */
uint8_t server_pk[32];     /* public key to server_sk */
uint8_t client_pk[32];     /* the client's public key */
uint8_t seed[32];          /* 32 random bytes */
uint8_t buf[48];           /* buffer for the key exchange messages */
uint8_t session_key[32];   /* the resulting session key */
int fd;                    /* the socket of the connection */

/* (generate random bytes in seed here) */
crypto_kex_xk1_init_server(&amp;server_ctx, seed, server_sk, server_pk);
if (read(fd, buf, 32) != 32)
    return -1;
crypto_kex_xk1_2(&amp;server_ctx, buf, buf);
if (write(fd, buf, 48) != 48)
    return -2;
if (read(fd, buf, 48) != 48)
    return -3;
if (crypto_kex_xk1_4(&amp;server_ctx, session_key, client_pk, buf) != 0)
    return -4;

/* authenticate client using client_pk now if possible */

/* key exchange complete;
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
  <a class="Xr" href="crypto_kex_x_init_client.html">crypto_kex_x_init_client(3monocypher)</a>,
  <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>,
  <a class="Xr" href="intro.html">intro(3monocypher)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
These functions are equivalent to an implementation of the XK1 pattern of the
  Noise protocol framework.
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
The <code class="Fn">crypto_kex_xk1_init_client</code>(),
  <code class="Fn">crypto_kex_xk1_init_server</code>(),
  <code class="Fn">crypto_kex_xk1_1</code>(),
  <code class="Fn">crypto_kex_xk1_2</code>(),
  <code class="Fn">crypto_kex_xk1_3</code>(), and
  <code class="Fn">crypto_kex_xk1_4</code>() functions first appeared in
  Monocypher 2.1.0.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 6, 2019</td>
    <td class="foot-os">OpenBSD 6.4</td>
  </tr>
</table>
</body>
</html>
