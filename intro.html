<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>INTRO(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">INTRO(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">INTRO(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">intro</code> &#x2014;
<div class="Nd">introduction to Monocypher</div>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Monocypher is a cryptographic library. It provides functions for authenticated
  encryption, hashing, password key derivation, key exchange, and public key
  signatures.
<section class="Ss">
<h2 class="Ss" id="Authenticated_encryption"><a class="permalink" href="#Authenticated_encryption">Authenticated
  encryption</a></h2>
<a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a> and
  <a class="Xr" href="crypto_unlock.html">crypto_unlock(3monocypher)</a> use the
  Chacha20 cipher and the Poly1305 one time authenticator. An incremental
  interface is also available.
<p class="Pp">Chacha20 is a stream cipher based on a cryptographic hash
    function. It runs efficiently on a wide variety of hardware, and unlike AES
    naturally runs in constant time on all hardware.</p>
<p class="Pp">Poly1305 is a one time authenticator, derived from Carter &amp;
    Wegman universal hashing. It is very fast and very simple.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Hashing"><a class="permalink" href="#Hashing">Hashing</a></h2>
<a class="Xr" href="crypto_blake2b.html">crypto_blake2b(3monocypher)</a>
  implements the Blake2b hash. Blake2b combines the security of SHA-3 and the
  speed of MD5. It is immune to length extension attacks and provides a keyed
  mode that makes it a safe, easy to use authenticator.
</section>
<section class="Ss">
<h2 class="Ss" id="Password_key_derivation"><a class="permalink" href="#Password_key_derivation">Password
  key derivation</a></h2>
<a class="Xr" href="crypto_argon2i.html">crypto_argon2i(3monocypher)</a>
  implements the Argon2i resource intensive hash algorithm. Argon2 won the
  password hashing competition in 2015. Unlike Scrypt, Argon2i is immune to
  timing attacks.
</section>
<section class="Ss">
<h2 class="Ss" id="Key_exchange"><a class="permalink" href="#Key_exchange">Key
  exchange</a></h2>
The
  <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
  and
  <a class="Xr" href="crypto_kex_x_init_client.html">crypto_kex_x_init_client(3monocypher)</a>
  families of functions, provide key exhange protocols with forward secrecy.
<p class="Pp">If more control over the key exchange is required, there is
    <a class="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
    which implements X25519, an elliptic curve Diffie Hellman key exchange
    algorithm based on Curve25519. X25519 derives a shared secret from two
    private/public key pairs. It is fast, simple, and relatively easy to
    implement securely.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Public_key_signatures"><a class="permalink" href="#Public_key_signatures">Public
  key signatures</a></h2>
<a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a> and
  <a class="Xr" href="crypto_check.html">crypto_check(3monocypher)</a> implement
  EdDSA, with Curve25519 and Blake2b. This is the same as the more famous
  Ed25519, with SHA-512 replaced by the faster and more secure Blake2b. Ed25519
  (EdDSA with SHA-512), is supported as a compilation option.
</section>
<section class="Ss">
<h2 class="Ss" id="Constant_time_comparison"><a class="permalink" href="#Constant_time_comparison">Constant
  time comparison</a></h2>
<a class="Xr" href="crypto_verify16.html">crypto_verify16(3monocypher)</a>,
  <a class="Xr" href="crypto_verify32.html">crypto_verify32(3monocypher)</a>,
  and <a class="Xr" href="crypto_verify64.html">crypto_verify64(3monocypher)</a>
  compare buffers in constant time. They should be used to compare secrets to
  prevent timing attacks.
</section>
<section class="Ss">
<h2 class="Ss" id="Memory_wipe"><a class="permalink" href="#Memory_wipe">Memory
  wipe</a></h2>
<a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a> wipes a
  buffer. It is meant to erase secrets when they are no longer needed, to reduce
  the chances of leaks.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr" href="crypto_argon2i.html">crypto_argon2i(3monocypher)</a>,
  <a class="Xr" href="crypto_argon2i_general.html">crypto_argon2i_general(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b.html">crypto_blake2b(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b_final.html">crypto_blake2b_final(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b_general.html">crypto_blake2b_general(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b_general_init.html">crypto_blake2b_general_init(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b_init.html">crypto_blake2b_init(3monocypher)</a>,
  <a class="Xr" href="crypto_blake2b_update.html">crypto_blake2b_update(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_encrypt.html">crypto_chacha20_encrypt(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_H.html">crypto_chacha20_H(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_init.html">crypto_chacha20_init(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_set_ctr.html">crypto_chacha20_set_ctr(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_stream.html">crypto_chacha20_stream(3monocypher)</a>,
  <a class="Xr" href="crypto_chacha20_x_init.html">crypto_chacha20_x_init(3monocypher)</a>,
  <a class="Xr" href="crypto_check.html">crypto_check(3monocypher)</a>,
  <a class="Xr" href="crypto_check_final.html">crypto_check_final(3monocypher)</a>,
  <a class="Xr" href="crypto_check_init.html">crypto_check_init(3monocypher)</a>,
  <a class="Xr" href="crypto_check_update.html">crypto_check_update(3monocypher)</a>,
  <a class="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
  <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_aead.html">crypto_lock_aead(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_auth_ad.html">crypto_lock_auth_ad(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_auth_message.html">crypto_lock_auth_message(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_final.html">crypto_lock_final(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_init.html">crypto_lock_init(3monocypher)</a>,
  <a class="Xr" href="crypto_lock_update.html">crypto_lock_update(3monocypher)</a>,
  <a class="Xr" href="crypto_poly1305.html">crypto_poly1305(3monocypher)</a>,
  <a class="Xr" href="crypto_poly1305_final.html">crypto_poly1305_final(3monocypher)</a>,
  <a class="Xr" href="crypto_poly1305_init.html">crypto_poly1305_init(3monocypher)</a>,
  <a class="Xr" href="crypto_poly1305_update.html">crypto_poly1305_update(3monocypher)</a>,
  <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a>,
  <a class="Xr" href="crypto_sign_final.html">crypto_sign_final(3monocypher)</a>,
  <a class="Xr" href="crypto_sign_init_first_pass.html">crypto_sign_init_first_pass(3monocypher)</a>,
  <a class="Xr" href="crypto_sign_init_second_pass.html">crypto_sign_init_second_pass(3monocypher)</a>,
  <a class="Xr" href="crypto_sign_public_key.html">crypto_sign_public_key(3monocypher)</a>,
  <a class="Xr" href="crypto_sign_update.html">crypto_sign_update(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock.html">crypto_unlock(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_aead.html">crypto_unlock_aead(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_auth_ad.html">crypto_unlock_auth_ad(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_auth_message.html">crypto_unlock_auth_message(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_final.html">crypto_unlock_final(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_init.html">crypto_unlock_init(3monocypher)</a>,
  <a class="Xr" href="crypto_unlock_update.html">crypto_unlock_update(3monocypher)</a>,
  <a class="Xr" href="crypto_verify16.html">crypto_verify16(3monocypher)</a>,
  <a class="Xr" href="crypto_verify32.html">crypto_verify32(3monocypher)</a>,
  <a class="Xr" href="crypto_verify64.html">crypto_verify64(3monocypher)</a>,
  <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a>,
  <a class="Xr" href="crypto_x25519.html">crypto_x25519(3monocypher)</a>,
  <a class="Xr" href="crypto_x25519_public_key.html">crypto_x25519_public_key(3monocypher)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_CONSIDERATIONS"><a class="permalink" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a></h1>
Using cryptography securely is difficult. Flaws that never manifest under normal
  use might be exploited by a clever adversary. Cryptographic libraries are easy
  to misuse. Even Monocypher allows a number of fatal mistakes.
<p class="Pp">Users should follow a formal introduction to cryptography. We
    currently recommend the https://www.crypto101.io/ online course.</p>
<section class="Ss">
<h2 class="Ss" id="Random_number_generation"><a class="permalink" href="#Random_number_generation">Random
  number generation</a></h2>
Use the facilities of your operating system. Avoid user space random number
  generators. They are easy to misuse, which has lead to countless
  vulnerabilities in the past. For instance, the random stream may be repeated
  if one is not careful with multi-threading, and forward secrecy is lost
  without proper key erasure.
<p class="Pp">Different system calls are available on different systems:</p>
<ul class="Bl-bullet">
  <li>Recent versions of Linux (glibc &gt;= 2.25, Linux &gt;= 3.17), provide
      <code class="Fn">getrandom</code>() in
      <code class="In">&lt;<a class="In">linux/random.h</a>&gt;</code>. Do not
      set any flag.</li>
  <li>BSD provides <code class="Fn">arc4random_buf</code>() in
      <code class="In">&lt;<a class="In">stdlib.h</a>&gt;</code> or
      <code class="In">&lt;<a class="In">bsd/stdlib.h</a>&gt;</code>. This is
      easier to use than <code class="Fn">getrandom</code>().</li>
  <li>Windows provides <code class="Fn">BCryptGenRandom</code>().</li>
</ul>
<p class="Pp">The <span class="Pa">/dev/urandom</span> special file may be used
    on systems that do not provide an easy to use system call. Be careful
    though, being a file makes <span class="Pa">/dev/urandom</span> hard to use
    correctly and securely. Reads may be interrupted, and more attacks are
    possible on a file than on a system call.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Timing_attacks"><a class="permalink" href="#Timing_attacks">Timing
  attacks</a></h2>
Monocypher runs in &quot;constant time&quot;. There is no flow from secrets to
  timings. No secret dependent indices, no secret dependent branches.
  Nevertheless, there are a couple important caveats.
<p class="Pp">Comparing secrets should be done with constant-time comparison
    functions, such as
    <a class="Xr" href="crypto_verify16.html">crypto_verify16(3monocypher)</a>,
    <a class="Xr" href="crypto_verify32.html">crypto_verify32(3monocypher)</a>,
    or
    <a class="Xr" href="crypto_verify64.html">crypto_verify64(3monocypher)</a>.
    Do not use standard comparison functions. They tend to stop as soon as a
    difference is spotted. In many cases, this enables attackers to recover the
    secrets and destroy all security.</p>
<p class="Pp">The Poly1305 authenticator, X25519, and EdDSA use multiplication.
    Some older processors do not multiply in constant time. If the target
    platform is something other than x86, x86_64, ARM or ARM64, double check how
    it handles multiplication.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Data_compression"><a class="permalink" href="#Data_compression">Data
  compression</a></h2>
Encryption does not hide the length of the input plaintext. Most compression
  algorithms work by using fewer bytes to encode previously seen data or common
  characters. If an attacker can add data to the input before it is compressed
  and encrypted, they can observe changes to the ciphertext length to recover
  secrets from the input. Researchers have demonstrated an attack on HTTPS to
  steal session cookies when compression is enabled, dubbed &quot;CRIME&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="Forward_secrecy"><a class="permalink" href="#Forward_secrecy">Forward
  secrecy</a></h2>
Long term secrets cannot be expected to stay safe indefinitely. Users may reveal
  them by mistake, or the host computer might have a vulnerability and be
  compromised. To mitigate this problem, some protocols guarantee that past
  messages are not compromised even if the long term keys are. This is done by
  generating temporary keys, then encrypting messages using them. Monocypher
  provides the
  <a class="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
  and
  <a class="Xr" href="crypto_kex_x_init_client.html">crypto_kex_x_init_client(3monocypher)</a>
  families of functions, which provide forward secrecy.
<p class="Pp">In general, secrets that went through a computer should not be
    compromised when this computer is stolen or infected at a later point.</p>
<p class="Pp">A first layer of defence is to explicitly wipe secrets as soon as
    they are no longer used. Monocypher already wipes its own temporary buffers,
    and contexts are erased with the <code class="Fn">crypto_*_final</code>()
    functions. The secret keys and messages however are the responsibility of
    the user. Use
    <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a> to erase
    them.</p>
<p class="Pp">A second layer of defence is to ensure those secrets are not
    swapped to disk while they are used. There are several ways to do this. The
    most secure is to disable swapping entirely. Doing so is recommended on
    sensitive machines. Another way is to encrypt the swap partition (this is
    less safe). Finally, swap can be disabled locally &#x2013; this is often the
    only way.</p>
<p class="Pp">UNIX systems can disable swap for specific buffers with
    <code class="Fn">mlock</code>(), and disable swap for the whole process with
    <code class="Fn">mlockall</code>(). Windows can disable swap for specific
    buffers with <code class="Fn">VirtualLock</code>().</p>
<p class="Pp">Core dumps cause similar problems. Disable them. Also beware of
    suspend to disk (deep sleep mode), which writes all RAM to disk regardless
    of swap policy, as well as virtual machine snapshots. Erasing secrets with
    <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a> is often
    the only way to mitigate these dangers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Undefined_behaviour"><a class="permalink" href="#Undefined_behaviour">Undefined
  behaviour</a></h2>
Monocypher is a C library. C is notoriously unsafe. Using Monocypher incorrectly
  can trigger undefined behaviour. This can lead to data corruption, data theft,
  or even arbitrary code execution.
<p class="Pp">Consider binding to a safe language if possible.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 6, 2019</td>
    <td class="foot-os">OpenBSD 6.4</td>
  </tr>
</table>
</body>
</html>
