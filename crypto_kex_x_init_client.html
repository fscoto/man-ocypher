<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">CRYPTO_KEX_X_INIT_CLIENT(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm" title="Nm">crypto_kex_x_init_client</code>,
  <code class="Nm" title="Nm">crypto_kex_x_init_server</code>,
  <code class="Nm" title="Nm">crypto_kex_x_1</code>,
  <code class="Nm" title="Nm">crypto_kex_x_2</code> &#x2014;
<div class="Nd" title="Nd">one way key exchange for establishing secure
  channels</div>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In" title="In">#include
  &lt;<a class="In" title="In">monocypher.h</a>&gt;</code>
<div class="Pp"></div>
<var class="Ft" title="Ft">void</var>
<br/>
<code class="Fn" title="Fn">crypto_kex_x_init_client</code>(<var class="Fa" title="Fa">crypto_kex_ctx
  *ctx</var>, <var class="Fa" title="Fa">uint8_t random_seed[32]</var>,
  <var class="Fa" title="Fa">const uint8_t local_sk[32]</var>,
  <var class="Fa" title="Fa">const uint8_t local_pk[32]</var>,
  <var class="Fa" title="Fa">const uint8_t remote_pk[32]</var>);
<div class="Pp"></div>
<var class="Ft" title="Ft">void</var>
<br/>
<code class="Fn" title="Fn">crypto_kex_x_init_server</code>(<var class="Fa" title="Fa">crypto_kex_ctx
  *ctx</var>, <var class="Fa" title="Fa">const uint8_t local_sk[32]</var>,
  <var class="Fa" title="Fa">const uint8_t local_pk[32]</var>);
<div class="Pp"></div>
<var class="Ft" title="Ft">void</var>
<br/>
<code class="Fn" title="Fn">crypto_kex_x_1</code>(<var class="Fa" title="Fa">crypto_kex_ctx
  *ctx</var>, <var class="Fa" title="Fa">uint8_t session_key[32]</var>,
  <var class="Fa" title="Fa">uint8_t msg1[80]</var>);
<div class="Pp"></div>
<var class="Ft" title="Ft">void</var>
<br/>
<code class="Fn" title="Fn">crypto_kex_x_2</code>(<var class="Fa" title="Fa">crypto_kex_ctx
  *ctx</var>, <var class="Fa" title="Fa">uint8_t session_key[32]</var>,
  <var class="Fa" title="Fa">uint8_t remote_pk[32]</var>,
  <var class="Fa" title="Fa">conts uint8_t msg1[80]</var>);
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These functions perform a key exchange between a
  <i class="Em" title="Em">client</i> and a <i class="Em" title="Em">server</i>
  to establish a secure channel. The result of the key exchange is a
  <i class="Em" title="Em">session key</i> that is suitable for use with
  <a class="Xr" title="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>.
  The <i class="Em" title="Em">server</i> generates an X25519 secret key and its
  corresponding public key ahead of time using
  <a class="Xr" title="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>
  when the key exchange starts. The <i class="Em" title="Em">client</i> does not
  need to know the <i class="Em" title="Em">server's</i> public key before
  performing the key exchange. The <i class="Em" title="Em">client</i> initiates
  the key exchange.
<div class="Pp"></div>
These functions differ from the
  <a class="Xr" title="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
  functions in that the functions described in this page can be used even if a
  server is offline (i.e. asynchronous communication); they have lower security
  guarantees, see
  <a class="Sx" title="Sx" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a>. If you can, always prefer
  <a class="Xr" title="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>.
<h2 class="Ss" title="Ss" id="Key_exchange_as_the_client"><a class="permalink" href="#Key_exchange_as_the_client">Key
  exchange as the client</a></h2>
When starting a new connection to the server, the client first reads the
  server's public key from the network; then it calls
  <code class="Fn" title="Fn">crypto_client_x_init_client</code>() to initialize
  a <var class="Vt" title="Vt">crypto_kex_ctx</var>. The arguments to
  <code class="Fn" title="Fn">crypto_client_x_init_client</code>() are:
<dl class="Bl-tag">
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt><var class="Fa" title="Fa">ctx</var></dt>
  <dd>A pointer to a <var class="Vt" title="Vt">crypto_kex_ctx</var>.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt><var class="Fa" title="Fa">random_seed</var></dt>
  <dd>32 randomly generated bytes. See
      <a class="Xr" title="Xr" href="intro.html">intro(3monocypher)</a> for
      advice about generating random bytes (use the operating system's random
      number generator). This argument is not constant because it is wiped after
      use.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt><var class="Fa" title="Fa">local_sk</var></dt>
  <dd>A 32-byte secret random number. This is a long-term secret used to
      identify the respective party.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt><var class="Fa" title="Fa">local_pk</var></dt>
  <dd>The public key corresponding to the
      <var class="Fa" title="Fa">local_sk</var>, generated using
      <a class="Xr" title="Xr" href="crypto_key_exchange_public_key.html">crypto_key_exchange_public_key(3monocypher)</a>.
      If <code class="Dv" title="Dv">NULL</code>, the public key will be
      generated for you.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt><var class="Fa" title="Fa">remote_pk</var></dt>
  <dd>The public key of the server.</dd>
</dl>
<div class="Pp"></div>
After creating initialising <var class="Fa" title="Fa">ctx</var>, the client
  calls <code class="Fn" title="Fn">crypto_kex_x_1</code>() to generate
  <var class="Fa" title="Fa">msg1</var> and the
  <var class="Fa" title="Fa">session_key</var>. It proceeds to send
  <var class="Fa" title="Fa">msg1</var> to the server to complete the key
  exchange.
<h2 class="Ss" title="Ss" id="Key_exchange_as_the_server"><a class="permalink" href="#Key_exchange_as_the_server">Key
  exchange as the server</a></h2>
When accepting a new connection from a client, the server calls
  <code class="Fn" title="Fn">crypto_client_xk1_init_server</code>() to
  initialize a <var class="Vt" title="Vt">crypto_kex_ctx</var>. The arguments to
  <code class="Fn" title="Fn">crypto_client_xk1_init_server</code>() are
  identical to the arguments to
  <code class="Fn" title="Fn">crypto_client_xk1_init_client</code>(), except
  that the server does not need a <var class="Fa" title="Fa">random_seed</var>;
  no <var class="Fa" title="Fa">remote_pk</var> can be specified because the
  server authenticates clients only once the handshake completes, which is
  application logic and not part of the key exchange protocol.
<div class="Pp"></div>
After initializing <var class="Fa" title="Fa">ctx</var>, the server waits for
  the client to send <var class="Fa" title="Fa">msg1</var> and reads it from the
  network. The server then calls
  <code class="Fn" title="Fn">crypto_kex_x_2</code>() with
  <var class="Fa" title="Fa">msg1</var>, which yields
  <var class="Fa" title="Fa">session_key</var> and
  <var class="Fa" title="Fa">remote_pk</var>, the client's public key. The
  server can use this to authenticate clients by their public key;
  <i class="Em" title="Em">if possible, always authenticate clients</i>.
  <code class="Fn" title="Fn">crypto_kex_x_2</code>() returns zero on success
  and -1 if the client's message mismatches the key exchange until now.
  <i class="Em" title="Em">Always check the return value</i>. This function also
  wipes the data in <var class="Fa" title="Fa">ctx</var>.
<h1 class="Sh" title="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<code class="Fn" title="Fn">crypto_kex_x_init_client</code>(),
  <code class="Fn" title="Fn">crypto_kex_x_init_server</code>() and
  <code class="Fn" title="Fn">crypto_kex_x_1</code>() return nothing.
  <code class="Fn" title="Fn">crypto_kex_x_2</code>() returns 0 on success or -1
  if the messages were corrupt or mismatched the server's identity. Corruption
  can be caused by transmission errors, programmer error, or an attacker's
  interference.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
These examples use *NIX networking functions to keep the examples concise, but
  any kind of networking code will work. It is assumed that the client and
  server have already established a connection with each other.
<div class="Pp"></div>
Client:
<div class="Pp"></div>
<div class="Bd Bd-indent">
<pre class="Li">
crypto_kex_ctx client_ctx; /* key exchange context */ 
uint8_t sk[32];            /* 32 random bytes long-term secret key */ 
uint8_t their_pk[32];      /* the server's public key 
                            * (known ahead of time) */ 
uint8_t seed[32];          /* 32 random bytes */ 
uint8_t buf[80];           /* buffer for the key exchange messages */ 
uint8_t session_key[32];   /* the resulting session key */ 
int fd;                    /* the socket of the connection */ 
 
/* (generate random bytes in seed) */ 
crypto_kex_x_init_client(&amp;client_ctx, seed, sk, NULL, their_pk); 
crypto_kex_x_1(&amp;client_ctx, session_key, buf); 
if (write(fd, buf, 80) != 80) 
    return -2; 
/* key exchange complete; 
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
<div class="Pp"></div>
Server:
<div class="Pp"></div>
<div class="Bd Bd-indent">
<pre class="Li">
crypto_kex_ctx server_ctx; /* key exchange context */ 
uint8_t sk[32];            /* 32 random bytes long-term secret key */ 
uint8_t my_pk[32];         /* public key to sk */ 
uint8_t their_pk[32];      /* the client's public key */ 
uint8_t seed[32];          /* 32 random bytes */ 
uint8_t buf[80];           /* buffer for the key exchange messages */ 
uint8_t session_key[32];   /* the resulting session key */ 
int fd;                    /* the socket of the connection */ 
 
crypto_kex_x_init_server(&amp;server_ctx, sk, my_pk); 
if (read(fd, buf, 80) != 80) 
    return -2; 
crypto_kex_1_2(&amp;server_ctx, session_key, their_pk, buf); 
/* key exchange complete; 
 * send/receive messages encrypted with crypto_lock() now */
</pre>
</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr" title="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
  <a class="Xr" title="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>,
  <a class="Xr" title="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>,
  <a class="Xr" title="Xr" href="intro.html">intro(3monocypher)</a>
<h1 class="Sh" title="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
These functions are equivalent to an implementation of the X pattern of the
  Noise protocol framework.
<h1 class="Sh" title="Sh" id="SECURITY_CONSIDERATIONS"><a class="permalink" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a></h1>
Unlike the
  <a class="Xr" title="Xr" href="crypto_kex_xk1_init_client.html">crypto_kex_xk1_init_client(3monocypher)</a>
  family of functions, the functions described on this page suffer from a number
  of security issues:
<dl class="Bl-tag">
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt>Limited forward secrecy</dt>
  <dd>If an attacker manages to steal the server's long-term secret key, past
      messages may be recovered.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt>Replay attacks</dt>
  <dd>The server does not send a random challenge in this.</dd>
  <dt>&#x00A0;</dt>
  <dd>&#x00A0;</dd>
  <dt>Key compromise impersonation</dt>
  <dd>If an attacker manages to steal the server's long-term secret key, the
      attacker can impersonate <i class="Em" title="Em">any</i> client to that
      server; if client identity is tied to authorization, this also means that
      authorization requirements can be bypassed.</dd>
</dl>
<div class="Pp"></div>
The reason they are provided is because they work even if the other party cannot
  respond to a key exchange immediately (e.g. if the server may not always be
  available; consider something like crash dumps where a program may be used
  temporarily in an offline environment).</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 6, 2019</td>
    <td class="foot-os">OpenBSD 6.4</td>
  </tr>
</table>
</body>
</html>
