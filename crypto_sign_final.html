<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>CRYPTO_SIGN_INIT_FIRST_PASS(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTO_SIGN_INIT_FIRST_PASS(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">CRYPTO_SIGN_INIT_FIRST_PASS(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">crypto_sign_init_first_pass</code>,
    <code class="Nm">crypto_sign_update</code>,
    <code class="Nm">crypto_sign_final</code>,
    <code class="Nm">crypto_sign_init_second_pass</code>,
    <code class="Nm">crypto_check_init</code>,
    <code class="Nm">crypto_check_update</code>,
    <code class="Nm">crypto_check_final</code> &#x2014;
    <span class="Nd">incremental public key signatures</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">monocypher.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_sign_init_first_pass</code>(<var class="Fa">crypto_sign_ctx
    *ctx</var>, <var class="Fa">const uint8_t secret_key[32]</var>,
    <var class="Fa">const uint8_t public_key[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_sign_update</code>(<var class="Fa">crypto_sign_ctx
    *ctx</var>, <var class="Fa">const uint8_t *message</var>,
    <var class="Fa">size_t message_size</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_sign_final</code>(<var class="Fa">crypto_sign_ctx
    *ctx</var>, <var class="Fa">uint8_t signature[64]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_sign_init_second_pass</code>(<var class="Fa">crypto_sign_ctx
    *ctx</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_check_init</code>(<var class="Fa">crypto_check_ctx
    *ctx</var>, <var class="Fa">const uint8_t signature[64]</var>,
    <var class="Fa">const uint8_t public_key[32]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_check_update</code>(<var class="Fa">crypto_check_ctx
    *ctx</var>, <var class="Fa">const uint8_t *message</var>,
    <var class="Fa">size_t message_size</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">crypto_check_final</code>(<var class="Fa">crypto_check_ctx
    *ctx</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">These functions are variants of
    <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a> and
    <a class="Xr" href="crypto_check.html">crypto_check(3monocypher)</a>. Prefer
    those simpler functions if possible.</p>
<p class="Pp">The arguments are the same as those described in
    <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a>.</p>
<p class="Pp">This incremental interface can be used to sign or verify messages
    too large to fit in a single buffer. The arguments are the same as the
    direct interface described in
    <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a>.</p>
<p class="Pp">The direct and incremental interface produce and accept the same
    signatures.</p>
<p class="Pp">Signing is done in two passes. This requires five steps:</p>
<ul class="Bl-bullet">
  <li>Initialisation of the first pass with
      <code class="Fn">crypto_sign_init_first_pass</code>(). The public key is
      optional, and will be recomputed if not provided. This recomputation
      doubles the execution time for short messages.</li>
  <li>The first pass proper, with
    <code class="Fn">crypto_sign_update</code>().</li>
  <li>Initialisation of the second pass with
      <code class="Fn">crypto_sign_init_second_pass</code>().</li>
  <li>The second pass proper, with <code class="Fn">crypto_sign_update</code>().
      The same update function is used for both passes.</li>
  <li>Signature generation with <code class="Fn">crypto_sign_final</code>().
      This also wipes the context.</li>
</ul>
<p class="Pp">Verification requires three steps:</p>
<ul class="Bl-bullet">
  <li>Initialisation with <code class="Fn">crypto_check_init</code>().</li>
  <li>Update with <code class="Fn">crypto_check_update</code>().</li>
  <li>Signature verification with
    <code class="Fn">crypto_check_final</code>().</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp"><code class="Fn">crypto_sign_init_first_pass</code>(),
    <code class="Fn">crypto_sign_init_second_pass</code>(),
    <code class="Fn">crypto_sign_update</code>(),
    <code class="Fn">crypto_sign_final</code>(),
    <code class="Fn">crypto_check_init</code>() and
    <code class="Fn">crypto_check_update</code>() return nothing.</p>
<p class="Pp"><code class="Fn">crypto_check_final</code>() returns 0 for
    legitimate messages and -1 for forgeries.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Sign a message:</p>
<div class="Bd Pp Bd-indent">
<pre>
const uint8_t sk       [ 32]; /* Secret key            */
const uint8_t pk       [ 32]; /* Public key (optional) */
const uint8_t message  [500]; /* Message to sign       */
uint8_t       signature[ 64]; /* Output signature      */
crypto_sign_ctx ctx;
crypto_sign_init_first_pass(&amp;ctx, sk, pk);
/* Wipe the secret key if no longer needed */
crypto_wipe(sk, 32);
for (size_t i = 0; i &lt; 500; i += 100) {
    crypto_sign_update(&amp;ctx, message + i, 100);
}
crypto_sign_init_second_pass(&amp;ctx);
for (size_t i = 0; i &lt; 500; i += 100) {
    crypto_sign_update(&amp;ctx, message + i, 100);
}
crypto_sign_final(&amp;ctx, signature);
</pre>
</div>
<p class="Pp">Check the above:</p>
<div class="Bd Pp Bd-indent">
<pre>
const uint8_t pk       [ 32]; /* Public key         */
const uint8_t message  [500]; /* Message to sign    */
const uint8_t signature[ 64]; /* Signature to check */
crypto_check_ctx ctx;
crypto_check_init(&amp;ctx, signature, pk);
for (size_t i = 0; i &lt; 500; i += 100) {
    crypto_check_update(&amp;ctx, message + i, 100);
}
if (crypto_check_final(&amp;ctx)) {
    /* Message is corrupted, abort processing */
} else {
    /* Message is genuine */
}

</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="crypto_blake2b.html">crypto_blake2b(3monocypher)</a>,
    <a class="Xr" href="crypto_key_exchange.html">crypto_key_exchange(3monocypher)</a>,
    <a class="Xr" href="crypto_lock.html">crypto_lock(3monocypher)</a>,
    <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a>,
    <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a>,
    <a class="Xr" href="intro.html">intro(3monocypher)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">These functions implement PureEdDSA with Curve25519 and Blake2b,
    as described in RFC 8032. This is the same as Ed25519, with Blake2b instead
    of SHA-512.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The <code class="Fn">crypto_sign_init_first_pass</code>(),
    <code class="Fn">crypto_sign_update</code>(),
    <code class="Fn">crypto_sign_final</code>(),
    <code class="Fn">crypto_sign_init_second_pass</code>(),
    <code class="Fn">crypto_check_init</code>(),
    <code class="Fn">crypto_check_update</code>(), and
    <code class="Fn">crypto_check_final</code>() functions first appeared in
    Monocypher 1.1.0.</p>
<p class="Pp"><b class="Sy">A critical security vulnerability</b> that caused
    all-zero signatures to be accepted was introduced in Monocypher 0.3; it was
    fixed in Monocypher 1.1.1 and 2.0.4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_CONSIDERATIONS"><a class="permalink" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a></h1>
<p class="Pp">Messages are not verified until the call to
    <code class="Fn">crypto_check_final</code>(). Messages may be stored before
    they are verified, but they cannot be <i class="Em">trusted</i>. Processing
    untrusted messages increases the attack surface of the system. Doing so
    securely is hard. Do not process messages before calling
    <code class="Fn">crypto_check_final</code>().</p>
<p class="Pp">When signing messages, the security considerations documented in
    <a class="Xr" href="crypto_sign.html">crypto_sign(3monocypher)</a> also
    apply.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION_DETAILS"><a class="permalink" href="#IMPLEMENTATION_DETAILS">IMPLEMENTATION
  DETAILS</a></h1>
<p class="Pp">EdDSA signatures require two passes that cannot be performed in
    parallel. There are ways around this limitation, but they all lower security
    in some way. For this reason, Monocypher does not support them.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">December 28, 2017</td>
    <td class="foot-os">OpenBSD 6.6</td>
  </tr>
</table>
</body>
</html>
